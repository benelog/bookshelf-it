---
date: 2006-01-20
title: 자바 병렬 프로그래밍
tags:[java]
---

## 인상깊은 부분

### 73쪽
> 특정 변수를 선언할 때 volatile 키워드를 지정하면, 컴파일러와 런타임 모두 '이 변수는 공유해 사용하고, 따라서 실행 순서를 재배치해서는 안된다'고 이해한다. volatile로 지정된 변수는 프로세서의 레지스터에 캐쉬되지도 않고, 프로세서 외부의 캐시에도 들어가지 않기 떄문에 volatile 변수의 값을 읽으면 항상 다른 스레드가 보관해둔 최신의 값을 읽어갈 수 있다.

### 205쪽
> 더군다나 자바에는 스레드가 가업을 실행하고 있을때 강제로 멈추도록 하는 방법이 없다.

### 210쪽
> 스태틱으로 선언된 interrupted 메서드를 호출하면 현재 스레드의 인터럽트 상태를 해제하고, 해제학 이지너의 값이 무엇이썼는지를 알려준다. (interrupted란느 이름으로는 유추하기 어려운 기능이다.) interrupted 메서드는 인터럽트 상태를 해제할 수 있는 유일한 방법이다.

### 248쪽
> 데몬 스레드는 예고 없이 종료될 수 있기 때문에 애플리케이션 내부에서 시작시키고 종료시키며 사용하기에는 그다지 좋은 방법이 아니다.

### 256쪽
> CPU를 많이 사용하느 작업의 경우 N개의 CPU를 탑재하고 있는 하드웨어에서 스레드 풀을 사용할 때는 스레드의 개수를 N+1로 맞추면 최적의 성능을 바루히한다고 알려져있다.

### 321쪽
Java6에서는 Lock 클래스 사용시에도 스레드 덤프에도 정보를 추가해준다는 내용. 그러나 그 정보가 암묵적인 락만큼 정확하지는 않다고 함.

### 342쪽
> JVM은 스레드를 대기 상태에 둘 때 두가지 방법을 사용할 수 있는데, 첫번쨰 방법은 스핀대기, 즉 락을 확보할 떄까지 계속해서 재시도하는 방법이고, 두번째 방법은 운영체제가 제공하는 긴으을 이용해 스레드를 실제 대기상태로 두는 방법이다. 두 가지 방법 가운데 어느 쪽에 효율적이냐 하는 문제의 답은 컨텍스트 스위칭에 필요한 자원의 양과 락을 확보할 때까지 걸리는 시간에 크게 좌우된다. 

### 361쪽
> 암달의 법칙에 따르면 애프리케이션의 확장성은 반드시 순차적으로 실행돼야만 하는 코드가 전체에서 얼마만큼의 비율을 차지하냐에 달렸다고 한다.

### 370쪽
> 이처럼 join메서드를 사용해 정상적으로 종료되는지를 확인하는 작업은 Runable인터페이스를 구현하는 대신 Therad클래스를 직접 상속받아 사용하느 편이 더 나은 몇 안되는 방버 가운데 하나이다.

### 381쪽
Thread.yield는 JVM 명세상 플랫폼에 따라 기대한 효과가 없을 수도 있음.


